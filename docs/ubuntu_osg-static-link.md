# 0. 运行 osgearth_city的步骤

## 0.1运行 静态链接版本的 osgearth_city的步骤
```sh
(1)  export OSG_FILE_PATH=/mnt/disk2/abner/zdev/nv/osgearth0x/3rd/osgearth/data/:$OSG_FILE_PATH

(2)  export OSGEARTH_NOTIFY_LEVEL=DEBUG

(3) 禁用代理： 
    unset http_proxy https_proxy HTTP_PROXY HTTPS_PROXY

(4) ./osgearth_city  >city.txt 2>&1
```

## 0.2运行 动态库链接版本的 osgearth_city的步骤

```sh
(1) 
>>>$    export REPO_ROOT_DIR=/mnt/disk2/abner/zdev/nv/osgearth0x/build_by_sh/ubuntu/install
>>>$    export LD_LIBRARY_PATH=${REPO_ROOT_DIR}/osgearthdll/lib/osgPlugins-3.7.0:${REPO_ROOT_DIR}/osgearthdll/lib/:${REPO_ROOT_DIR}/osgdll/lib/osgPlugins-3.7.0/:${REPO_ROOT_DIR}/osgdll/lib/

>>>$    echo $LD_LIBRARY_PATH 
(2)
>>>$    ./osgearth_city  >city.txt 2>&1
``` 

====================================================
# 1.static build support for dotosg wrapper and serialization libraries
<!-- osg静态库的编译支持 -->

* 1. Add two new macros USE_DOTOSGWRAPPER_LIBRARY and USE_SERIALIZER_WRAPPER_LIBRARY. Applications using static OSG must include corresponding static-link libraries and use these two macros to predefine native format wrappers. Please see osgstaticviewer and present3D in the attachment for details.
* 2. Add a LibraryWrapper.cpp file in each osgWrappers/deprecated-dotosg/... and osgWrappers/serializers/... subfolder, which calls all USE_...WRAPPERS macros inside. The LibraryWrapper file is automatically generated by the wrapper_includer.cpp (with some slight fixes), which is also attached for your reference. The deprecated-dotosg/osgAnimation is not included because it doesn't us  REGISTER_DOTOSGWRAPPER to define its wrappers.
>  
> (1)
>    #include <osgDB/Registry> // REGISTER_OSGPLUGIN() / REGISTER_OSGIMAGEPROCESSOR()
>    #include <osgDB/Registry> //      USE_OSGPLUGIN()    
> (2)
>    #include <osgDB/DotOsgWrapper>    // REGISTER_DOTOSGWRAPPER()    
>    #include <osgDB/Registry>        //       USE_DOTOSGWRAPPER()
> (3)
>    osg/src/osgWrappers/**/LibraryWrapper.cpp // dotosgwrapper_library_osg(void)     
>    #include <osgDB/Registry>                //USE_DOTOSGWRAPPER_LIBRARY()
> (4)
>    osg/src/osgWrappers/serializers/osg/LibraryWrapper.cpp // wrapper_serializer_library_osg()  
>    #include <osgDB/Registry>                             // USE_SERIALIZER_WRAPPER_LIBRARY()
> (5)
>    #include <osgDB/ObjectWrapper> // REGISTER_COMPRESSOR() 
>    #include <osgDB/Registry>     //   USE_COMPRESSOR_WRAPPER()
> ------------------------------------
> (6) osgViewer/GraphicsWindowX11.cpp // REGISTER_WINDOWINGSYSTEMINTERFACE2(X11, X11WindowingSystemInterface, OSGVIEWER_EXPORT) //-->graphicswindow_X11
>    osgViewer/GraphicsWindowWin32.cpp    //graphicswindow_Win32 
>    
>    #include <osgViewer/GraphicsWindow> // USE_GRAPHICSWINDOW() 

=======================================================
# 2.C++ 的静态库中的函数​符号存在但静态初始化未执行​​
## Q1 .静态库文件中确实有 `X11WindowingSystemInterface` 的符号， nm对可执行文件的检查没有找到相关符号
```sh
(base) abner@abner-XPS:/mnt/disk2/abner/zdev/nv/osgearth0x$ nm /home/abner/abner2/zdev/nv/osgearth0x/build_by_sh/ubuntu/install/osg/lib/libosgViewer.a | grep X11WindowingSystemInterface
00000000000000a8 b _ZL35s_proxy_X11WindowingSystemInterface
0000000000000000 W _ZN27X11WindowingSystemInterface13getNumScreensERKN3osg15GraphicsContext16ScreenIdentifierE
0000000000000000 W _ZN27X11WindowingSystemInterface17getScreenSettingsERKN3osg15GraphicsContext16ScreenIdentifierERNS1_14ScreenSettingsE
0000000000000000 W _ZN27X11WindowingSystemInterface17setScreenSettingsERKN3osg15GraphicsContext16ScreenIdentifierERKNS1_14ScreenSettingsE
0000000000000000 W _ZN27X11WindowingSystemInterface21createGraphicsContextEPN3osg15GraphicsContext6TraitsE
0000000000000000 W _ZN27X11WindowingSystemInterface23enumerateScreenSettingsERKN3osg15GraphicsContext16ScreenIdentifierERSt6vectorINS1_14ScreenSettingsESaIS6_EE
0000000000000000 W _ZN27X11WindowingSystemInterfaceC1Ev
0000000000000000 W _ZN27X11WindowingSystemInterfaceC2Ev
0000000000000000 n _ZN27X11WindowingSystemInterfaceC5Ev
0000000000000000 W _ZN27X11WindowingSystemInterfaceD0Ev
0000000000000000 W _ZN27X11WindowingSystemInterfaceD1Ev
0000000000000000 W _ZN27X11WindowingSystemInterfaceD2Ev
0000000000000000 n _ZN27X11WindowingSystemInterfaceD5Ev
0000000000000000 W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceEC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
0000000000000000 W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
0000000000000000 n _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceEC5ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
0000000000000000 W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceED1Ev
0000000000000000 W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceED2Ev
0000000000000000 n _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceED5Ev
0000000000000000 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEaSEPS1_
0000000000000000 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEC1Ev
0000000000000000 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEC2Ev
0000000000000000 n _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEC5Ev
0000000000000000 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceED1Ev
0000000000000000 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceED2Ev
0000000000000000 n _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceED5Ev
0000000000000000 W _ZNK3osg7ref_ptrI27X11WindowingSystemInterfaceE3getEv
0000000000000000 W _ZNK3osg7ref_ptrI27X11WindowingSystemInterfaceEptEv
0000000000000000 V _ZTI27X11WindowingSystemInterface
0000000000000000 V _ZTS27X11WindowingSystemInterface
0000000000000000 V _ZTV27X11WindowingSystemInterface
(base) abner@abner-XPS:/mnt/disk2/abner/zdev/nv/osgearth0x$ nm /mnt/disk2/abner/zdev/nv/osgearth0x/build_by_sh/ubuntu/install/osgearth/bin/osgearth_viewer | grep X11WindowingSystemInterface
(base) abner@abner-XPS:/mnt/disk2/abner/zdev/nv/osgearth0x$
```
从你的 `nm` 输出可以看出：
> 
> 1. **`libosgViewer.a` 中确实有 `X11WindowingSystemInterface` 的符号**  
>    说明 X11 窗口系统接口的代码已编译到静态库中（`W` 表示弱符号，`V` 表示虚表）。
> 
> 2. **`osgearth_viewer` 中未链接到 `X11WindowingSystemInterface`**  
>    `nm` 对可执行文件的检查没有找到相关符号，说明：
>    - 静态库中的 `X11WindowingSystemInterface` 未被正确链接到最终程序。
>    - 可能是 **链接顺序问题** 或 **静态初始化未触发**。
> 
---

### **根本原因**
`REGISTER_WINDOWINGSYSTEMINTERFACE2` 宏依赖静态初始化，但静态库（`.a`）中的符号可能因“未使用”被链接器优化掉（尤其是 `-O2` 以上优化时）。  
需要 **强制链接** X11 相关代码。
----------------------------
## Q2 符号存在但静态初始化未执行

采用方法 1：显式调用注册函数（无需修改构建系统）
在 osgearth_viewer.cpp的 main()开头添加：
```
#include <osgViewer/api/X11/GraphicsWindowX11>  // 使用头文件，而非 .cpp

int main(int argc, char** argv) {
    // 强制加载 X11 接口
    osg::ref_ptr<osg::GraphicsContext::WindowingSystemInterface> wsi = 
        osg::GraphicsContext::getWindowingSystemInterface();
    if (!wsi) {
        std::cerr << "ERROR: X11 WindowingSystemInterface not registered!" << std::endl;
        return 1;
    }
    // 正常启动代码...
}
```


而且
```sh
$  nm /mnt/disk2/abner/zdev/nv/osgearth0x/build_by_sh/ubuntu/install/osgearth/bin/osgearth_viewer | grep X11WindowingSystemInterface
0000000004ef7488 b _ZL35s_proxy_X11WindowingSystemInterface
000000000049d3e6 W _ZN27X11WindowingSystemInterface13getNumScreensERKN3osg15GraphicsContext16ScreenIdentifierE
000000000049d588 W _ZN27X11WindowingSystemInterface17getScreenSettingsERKN3osg15GraphicsContext16ScreenIdentifierERNS1_14ScreenSettingsE
000000000049d7c6 W _ZN27X11WindowingSystemInterface17setScreenSettingsERKN3osg15GraphicsContext16ScreenIdentifierERKNS1_14ScreenSettingsE
000000000049d940 W _ZN27X11WindowingSystemInterface21createGraphicsContextEPN3osg15GraphicsContext6TraitsE
000000000049d824 W _ZN27X11WindowingSystemInterface23enumerateScreenSettingsERKN3osg15GraphicsContext16ScreenIdentifierERSt6vectorINS1_14ScreenSettingsESaIS6_EE
000000000049d246 W _ZN27X11WindowingSystemInterfaceC1Ev
000000000049d246 W _ZN27X11WindowingSystemInterfaceC2Ev
000000000049d3b6 W _ZN27X11WindowingSystemInterfaceD0Ev
000000000049d320 W _ZN27X11WindowingSystemInterfaceD1Ev
000000000049d320 W _ZN27X11WindowingSystemInterfaceD2Ev
000000000049ebea W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceEC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
000000000049ebea W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
00000000004a343e W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceED1Ev
00000000004a343e W _ZN3osg29WindowingSystemInterfaceProxyI27X11WindowingSystemInterfaceED2Ev
00000000004a0106 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEaSEPS1_
00000000004a00b2 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEC1Ev
00000000004a00b2 W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceEC2Ev
00000000004a00cc W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceED1Ev
00000000004a00cc W _ZN3osg7ref_ptrI27X11WindowingSystemInterfaceED2Ev
00000000004a01a4 W _ZNK3osg7ref_ptrI27X11WindowingSystemInterfaceE3getEv
00000000004a0178 W _ZNK3osg7ref_ptrI27X11WindowingSystemInterfaceEptEv
0000000004aeb508 V _ZTI27X11WindowingSystemInterface
00000000031b7fd0 V _ZTS27X11WindowingSystemInterface
0000000004a038c0 V _ZTV27X11WindowingSystemInterface
```
但是
REGISTER_WINDOWINGSYSTEMINTERFACE2(X11, X11WindowingSystemInterface, OSGVIEWER_EXPORT) 没被调用到

## A-YuanbaoAI

根据你的描述，虽然 `X11WindowingSystemInterface` 的符号已成功链接到 `osgearth_viewer` 可执行文件中（通过 `nm` 验证），但 `REGISTER_WINDOWINGSYSTEMINTERFACE2` 的注册逻辑仍未触发。这表明 **符号存在但静态初始化未执行**，可能是由于 C++ 的静态初始化顺序问题或链接器优化导致。

---

### **根本原因**
1. **静态初始化未触发**  
   `REGISTER_WINDOWINGSYSTEMINTERFACE2` 宏会在编译单元（`.cpp` 文件）中生成静态注册代码，但该代码可能因以下原因未执行：
   - 链接器优化（如 `-O2` 或 `--gc-sections`）移除了“未使用”的静态初始化代码。
   - 静态初始化顺序问题（C++ 不保证不同编译单元中静态对象的初始化顺序）。

2. **显式调用 `getWindowingSystemInterface()` 未生效**  
   虽然你调用了该函数，但若底层注册逻辑未执行，接口仍无法加载。

---

### **解决方案**
#### **方法 1：强制触发静态初始化（推荐）**
在 `osgearth_viewer.cpp` 中，**显式引用 `X11WindowingSystemInterface` 的符号**，迫使链接器保留相关代码：
```cpp
#include <osgViewer/api/X11/GraphicsWindowX11>

// 强制引用符号，避免被优化
extern "C" void _ZN27X11WindowingSystemInterfaceC1Ev();  // 引用构造函数符号

int main(int argc, char** argv) {
    // 强制触发静态初始化
    _ZN27X11WindowingSystemInterfaceC1Ev();  // 显式调用构造函数（无实际作用，仅触发链接）

    // 显式加载接口
    osg::ref_ptr<osg::GraphicsContext::WindowingSystemInterface> wsi = 
        osg::GraphicsContext::getWindowingSystemInterface();
    if (!wsi) {
        std::cerr << "ERROR: X11 WindowingSystemInterface not registered!" << std::endl;
        return 1;
    }
    // 正常启动代码...
}
```
**原理**：  
- 直接引用 `X11WindowingSystemInterface` 的构造函数符号（通过 `nm` 输出的符号名），确保链接器保留相关代码。
- 调用 `getWindowingSystemInterface()` 进一步验证接口是否可用。

---

#### **方法 2：禁用链接器优化**
在 `CMakeLists.txt` 中，禁用链接器的符号优化：
```cmake
target_link_libraries(osgearth_viewer PRIVATE
    -Wl,--no-as-needed
    osgViewer
    osgDB
    -Wl,--no-gc-sections  # 禁止移除未使用的段
)
```

---

#### **方法 3：修改 OSG 源码（长期方案）**
在 OSG 的 `GraphicsWindowX11.cpp` 中，**显式导出注册函数**：
```cpp
// 在 GraphicsWindowX11.cpp 末尾添加：
extern "C" OSGVIEWER_EXPORT void registerX11WindowingSystemInterface() {
    osg::GraphicsContext::setWindowingSystemInterface(new X11WindowingSystemInterface());
}
```
然后在 `osgearth_viewer.cpp` 中调用：
```cpp
extern "C" void registerX11WindowingSystemInterface();

int main(int argc, char** argv) {
    registerX11WindowingSystemInterface();  // 显式注册
    // ...
}
```
**优点**：  
- 完全控制注册逻辑，避免静态初始化问题。

---

#### **方法 4：动态加载 X11 插件（备用方案）**
如果静态注册仍失败，尝试动态加载 OSG 的 X11 插件：
```cpp
#include <osgDB/DynamicLibrary>

int main(int argc, char** argv) {
    // 强制加载 X11 插件（假设插件路径已知）
    osgDB::DynamicLibrary* lib = osgDB::DynamicLibrary::loadLibrary(
        "/path/to/osgPlugins-3.7.0/libosgdb_x11.so"
    );
    if (!lib) {
        std::cerr << "Failed to load X11 plugin!" << std::endl;
        return 1;
    }
    // 正常启动代码...
}
```

---

### **验证是否修复**
1. **检查注册是否生效**  
   运行程序后，观察日志中是否出现：
   ```
   Debug: Loaded X11 WindowingSystemInterface
   ```
   或调用 `getWindowingSystemInterface()` 是否返回非空指针。

2. **符号是否被调用**  
   使用 `gdb` 调试，在 `REGISTER_WINDOWINGSYSTEMINTERFACE2` 处设断点，确认是否触发：
   ```bash
   gdb ./osgearth_viewer
   (gdb) b GraphicsWindowX11.cpp:REGISTER_WINDOWINGSYSTEMINTERFACE2
   (gdb) run
   ```

---

### **总结**
| 方法                | 适用场景                         | 优点                          | 缺点                          |
|---------------------|----------------------------------|-------------------------------|-------------------------------|
| **方法 1**（强制引用符号） | 符号已链接但未初始化             | 无需修改构建系统              | 依赖符号名，可能随版本变化     |
| **方法 2**（禁用优化）   | 链接器优化导致的问题             | 简单直接                      | 可能增加二进制大小             |
| **方法 3**（修改 OSG）  | 长期维护项目                     | 根治问题                      | 需修改 OSG 源码并重新编译      |
| **方法 4**（动态加载）  | 插件化环境                       | 灵活                          | 需知道插件路径                |

**推荐步骤**：  
1. **优先尝试方法 1**（强制引用符号），验证是否触发注册。  
2. 若无效，**使用方法 2**（禁用链接器优化）。  
3. 长期项目建议 **使用方法 3**（修改 OSG 源码）。  

如果问题仍未解决，请提供：  
- `osgearth_viewer` 的完整编译命令和链接日志（`make VERBOSE=1`）。  
- `gdb` 调试时 `REGISTER_WINDOWINGSYSTEMINTERFACE2` 是否被调用的信息。

====================================================

# 3.静态库liba.a 中全局静态变量 在exe中的初始化

> 静态库liba.a 中 A.cpp中有 全局静态变量"static  CA s_a" 和 函数"void  dummyFunc()";
> exe链接liba.a,且在 exe.cpp中 调用 了 dummyFunc(),则 A.cpp中的代码会被链接到exe中且s_a会被初始化。如果exe中没有调用dummyFunc(),则A.cpp中的代码不会被链接到exe中。 
> 请问为什么

这个问题涉及到 **C/C++ 的静态库链接规则** 和 **编译器的符号优化行为**。以下是详细解释：

---

### **1. 静态库（`.a`）的链接规则**
静态库（`.a` 文件）本质上是一组 **已编译目标文件（`.o`）的集合**。链接器（`ld`）在处理静态库时，遵循以下规则：
- **按需链接（--gc-sections）**：链接器默认只将 **被直接或间接引用的目标文件** 从静态库中提取到最终可执行文件中。
- **未引用的目标文件会被丢弃**：如果某个目标文件（如 `A.cpp` 生成的 `A.o`）中的符号（函数/变量）未被任何代码显式引用，则该目标文件 **不会被链接到最终可执行文件**。

---

### **2. 你的例子分析**
#### **情况 1：`exe` 调用了 `dummyFunc()`**
- **链接器行为**：
  1. 发现 `exe.cpp` 中调用了 `dummyFunc()`，需要从 `liba.a` 中解析该符号。
  2. 在 `liba.a` 中找到 `A.o`（包含 `dummyFunc()` 的实现），将其链接到 `exe`。
  3. 由于 `A.o` 被链接，其中的 **所有符号**（包括 `s_a`）也会被保留，且静态变量 `s_a` 会在程序启动时初始化。

- **结果**：
  - `A.cpp` 的代码（包括 `s_a`）被链接到 `exe`。
  - `s_a` 的构造函数/初始化代码在 `main()` 前执行。

#### **情况 2：`exe` 未调用 `dummyFunc()`**
- **链接器行为**：
  1. `exe.cpp` 未引用 `liba.a` 中的任何符号。
  2. 链接器认为 `A.o` 是“未使用的代码”，**直接丢弃整个 `A.o`**。
  3. 因此，`s_a` 的初始化代码也未被包含在 `exe` 中。

- **结果**：
  - `A.cpp` 的代码（包括 `s_a`）**不会出现在最终可执行文件**中。
  - `s_a` 的初始化代码永远不会执行。

---

### **3. 为什么会有这种设计？**
这种行为的根本原因是 **减少可执行文件的体积** 和 **优化性能**：
1. **减少体积**：避免将未使用的代码链接到最终程序。
2. **加快链接速度**：链接器无需处理无关的目标文件。
3. **避免冗余初始化**：静态变量的初始化可能涉及复杂操作（如内存分配），丢弃未使用的变量可节省启动时间。

---

### **4. 如何强制链接静态库中的目标文件？**
如果希望即使未调用 `dummyFunc()` 也保留 `A.o` 中的代码（例如确保 `s_a` 被初始化），可以通过以下方法实现：

#### **方法 1：显式引用符号**
在 `exe.cpp` 中强制引用 `s_a` 或 `dummyFunc()`：
```cpp
// 声明外部符号
extern void dummyFunc();
extern int s_a_dummy_value;  // 假设 s_a 有一个公开的成员变量

int main() {
    // 不调用 dummyFunc()，但强制引用符号
    (void)dummyFunc;          // 阻止编译器优化
    (void)s_a_dummy_value;    // 强制链接器保留 s_a
    return 0;
}
```

#### **方法 2：链接器选项**
在编译时禁用优化或强制链接所有符号：
```bash
g++ exe.cpp -la -Wl,--whole-archive  # 强制链接 liba.a 中的所有目标文件
```
或在 CMake 中：
```cmake
target_link_libraries(exe -Wl,--whole-archive liba -Wl,--no-whole-archive)
```

#### **方法 3：拆分目标文件**
将 `s_a` 和 `dummyFunc()` 分离到不同的 `.o` 文件中：
- 将 `s_a` 定义在 `A_static.cpp` 中。
- 将 `dummyFunc()` 定义在 `A_func.cpp` 中。
- 确保 `exe` 显式依赖 `A_static.o`。

---

### **5. 静态变量的初始化时机**
即使 `s_a` 被链接到 `exe`，它的初始化时机也取决于：
1. **全局静态变量**：在 `main()` 前初始化。
2. **局部静态变量**：在第一次使用时初始化（C++11 保证线程安全）。

---

### **总结**
| 行为                | 调用了 `dummyFunc()`           | 未调用 `dummyFunc()`           |
|---------------------|--------------------------------|--------------------------------|
| **`A.o` 是否链接**  | 是                             | 否                             |
| **`s_a` 是否初始化**| 是                             | 否                             |
| **原因**            | 链接器按需提取目标文件         | 目标文件被丢弃                 |

**关键点**：  
静态库的链接是 **“懒加载”** 的，只有被引用的目标文件才会被包含。若需强制保留代码，需显式引用符号或修改链接选项。


